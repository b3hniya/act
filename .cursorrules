# Act Monorepo - AI Contribution Guidelines

## Project Structure

- `apps/` - Applications (api-server, dashboard)
- `modules/` - Domain modules (customer, invoice, payment)
- `libs/` - Shared libraries (types, components, database, events)

## Commit Message Format

Use Conventional Commits format:

```
<type>(<scope>): <subject>
```

### Allowed Types
- `feat` - New feature
- `fix` - Bug fix
- `docs` - Documentation changes
- `style` - Code style changes (formatting)
- `refactor` - Code refactoring
- `perf` - Performance improvements
- `test` - Adding or updating tests
- `chore` - Maintenance tasks
- `revert` - Reverting commits
- `build` - Build system changes
- `ci` - CI/CD changes

### Rules
- Type is required and lowercase
- Subject is lowercase, no period, imperative mood

---

## How to Add a New Module

1. Create folder: `modules/<module-name>/`
2. Create `package.json`:
```json
{
  "name": "@act/<module-name>",
  "version": "1.0.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts"
}
```
3. Create structure:
```
modules/<module-name>/
├── api/
│   ├── <module>.controller.ts
│   ├── <module>.service.ts
│   └── <module>.module.ts
├── application/
│   ├── command/
│   ├── query/
│   └── event-handler/
├── repository/
└── index.ts
```
4. Export from `index.ts`:
```typescript
export * from './api';
```
5. Register in `apps/api-server/src/app.module.ts`:
```typescript
import { NewModule } from '@act/<module-name>';
@Module({ imports: [NewModule] })
```
6. Add `README.md` (see Documentation Guidelines below)

---

## Documentation Guidelines

### Module README

Module READMEs should focus on **business domain**, not technical implementation:

**Include:**
- Module purpose and responsibilities
- Domain concepts and entities
- Business rules
- API endpoints (user-facing description)
- Events (listens to / emits)
- Related modules

**Do NOT include:**
- Peer dependencies
- Folder structure
- Development commands
- Code examples for importing
- Technical setup instructions

Technical details belong in `.cursorrules` and `CONTRIBUTING.md`.

---

## How to Add a New Controller

Location: `modules/<module>/api/<name>.controller.ts`

```typescript
import { Controller, Get, Post, Body, Param } from '@nestjs/common';
import { CommandBus, QueryBus } from '@nestjs/cqrs';
import { GetCustomerListQuery } from '../application/query/get-customer-list/get-customer-list.query';
import { GetCustomerByIdQuery } from '../application/query/get-customer-by-id/get-customer-by-id.query';
import { AddCustomerCommand } from '../application/command/add-customer/add-customer.command';

@Controller('<route>')
export class NameController {
  constructor(
    private readonly commandBus: CommandBus,
    private readonly queryBus: QueryBus,
  ) {}

  @Get()
  async findAll() {
    return this.queryBus.execute(new GetCustomerListQuery());
  }

  @Get(':id')
  async findOne(@Param('id') id: string) {
    return this.queryBus.execute(new GetCustomerByIdQuery(id));
  }

  @Post()
  async create(@Body() dto: CreateDto) {
    return this.commandBus.execute(new AddCustomerCommand(dto.name, dto.email));
  }
}
```

Register in module:
```typescript
import { CqrsModule } from '@nestjs/cqrs';

@Module({
  imports: [CqrsModule],
  controllers: [NameController],
})
```

---

## How to Add Endpoint to Existing Controller

Add method with decorator, using CommandBus/QueryBus:
```typescript
@Get('search')
async search(@Query('q') query: string) {
  return this.queryBus.execute(new SearchCustomerQuery(query));
}

@Put(':id')
async update(@Param('id') id: string, @Body() dto: UpdateDto) {
  return this.commandBus.execute(new UpdateCustomerCommand(id, dto));
}

@Delete(':id')
async remove(@Param('id') id: string) {
  return this.commandBus.execute(new DeleteCustomerCommand(id));
}
```

---

## How to Add a New Service (Facade/ACL)

Services act as a **Facade** and **Anti-Corruption Layer (ACL)** - they are the boundary between your module and external systems or other modules. Use them to:
- Integrate with external APIs
- Communicate with other modules
- Abstract third-party libraries
- Transform external data to domain models

Location: `modules/<module>/api/<name>.service.ts`

```typescript
import { Injectable } from '@nestjs/common';

@Injectable()
export class PaymentGatewayService {
  constructor(private readonly httpService: HttpService) {}

  async processPayment(amount: number, customerId: string): Promise<PaymentResult> {
    // Facade: abstracts external payment provider
    const response = await this.httpService.post('https://payment-api.com/charge', {
      amount,
      customer: customerId,
    });
    
    // ACL: transforms external response to domain model
    return {
      transactionId: response.data.id,
      status: this.mapStatus(response.data.status),
    };
  }

  private mapStatus(externalStatus: string): PaymentStatus {
    // Anti-corruption: map external values to domain values
    const statusMap = {
      'COMPLETED': PaymentStatus.Success,
      'FAILED': PaymentStatus.Failed,
      'PENDING': PaymentStatus.Pending,
    };
    return statusMap[externalStatus] ?? PaymentStatus.Unknown;
  }
}
```

Register in module:
```typescript
@Module({
  providers: [PaymentGatewayService],
  exports: [PaymentGatewayService],
})
```

**Note:** Controllers use CommandBus/QueryBus for domain operations. Services are for external integrations only.

---

## How to Add a New Command (CQRS)

Location: `modules/<module>/application/command/<command-name>/`

1. Create command class:
```typescript
// add-customer.command.ts
export class AddCustomerCommand {
  constructor(
    public readonly name: string,
    public readonly email: string,
  ) {}
}
```

2. Create handler:
```typescript
// add-customer.handler.ts
import { CommandHandler, ICommandHandler } from '@nestjs/cqrs';
import { AddCustomerCommand } from './add-customer.command';

@CommandHandler(AddCustomerCommand)
export class AddCustomerHandler implements ICommandHandler<AddCustomerCommand> {
  async execute(command: AddCustomerCommand) {
    const { name, email } = command;
    // Implementation
  }
}
```

3. Export from `application/index.ts`

---

## How to Add a New Query (CQRS)

Location: `modules/<module>/application/query/<query-name>/`

1. Create query class:
```typescript
// get-customer-list.query.ts
export class GetCustomerListQuery {
  constructor(
    public readonly page: number = 1,
    public readonly limit: number = 10,
  ) {}
}
```

2. Create handler:
```typescript
// get-customer-list.handler.ts
import { QueryHandler, IQueryHandler } from '@nestjs/cqrs';
import { GetCustomerListQuery } from './get-customer-list.query';

@QueryHandler(GetCustomerListQuery)
export class GetCustomerListHandler implements IQueryHandler<GetCustomerListQuery> {
  async execute(query: GetCustomerListQuery) {
    const { page, limit } = query;
    // Implementation
    return [];
  }
}
```

---

## How to Add a New Event Handler

Location: `modules/<module>/application/event-handler/<event-name>/`

**Important:** Event handlers must NOT directly access the database or perform business logic. They should only dispatch commands or queries.

```typescript
// on-invoice-added.handler.ts
import { EventsHandler, IEventHandler } from '@nestjs/cqrs';
import { CommandBus } from '@nestjs/cqrs';
import { InvoiceAddedEvent } from '@act/events';
import { UpdateCustomerDueCommand } from '../command/update-customer-due/update-customer-due.command';

@EventsHandler(InvoiceAddedEvent)
export class OnInvoiceAddedHandler implements IEventHandler<InvoiceAddedEvent> {
  constructor(private readonly commandBus: CommandBus) {}

  async handle(event: InvoiceAddedEvent) {
    const { invoiceId, customerId, amount } = event;
    
    // Dispatch command - do NOT access database directly
    await this.commandBus.execute(
      new UpdateCustomerDueCommand(customerId, amount)
    );
  }
}
```

**Rules for Event Handlers:**
- Use `CommandBus` to trigger write operations
- Use `QueryBus` to fetch data if needed
- Never inject repositories directly
- Never perform database operations directly
- Keep handlers thin - they orchestrate, not implement

---

## How to Add a New Database Schema

Location: `libs/database/src/schema/<domain>/<name>.schema.ts`

**Important:** 
- Database schemas must align with types defined in `libs/types`
- Each domain has its own PostgreSQL schema (e.g., `customer`, `invoice`)
- All tables within a domain share the same PostgreSQL schema

1. Create domain folder in `libs/database/src/schema/`:
```
libs/database/src/schema/<domain>/
├── <domain>.schema.ts
└── index.ts
```

2. Define the domain schema and tables:
```typescript
// product.schema.ts
import { pgSchema, varchar, uuid, timestamp, numeric } from 'drizzle-orm/pg-core';

// Define domain schema (PostgreSQL schema)
export const productSchema = pgSchema('product');

// All tables in this domain use the same schema
export const products = productSchema.table('products', {
  id: uuid('id').primaryKey().defaultRandom(),
  name: varchar('name', { length: 255 }).notNull(),
  price: numeric('price', { precision: 10, scale: 2 }).notNull(),
  description: varchar('description', { length: 1000 }),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
});

// Additional tables in the same domain share the schema
export const productHistory = productSchema.table('product_history', {
  id: uuid('id').primaryKey().defaultRandom(),
  productId: uuid('product_id').notNull().references(() => products.id),
  changeType: varchar('change_type', { length: 50 }).notNull(),
  changedAt: timestamp('changed_at').defaultNow().notNull(),
});
```

This creates:
- `product.products` table
- `product.product_history` table

3. Export from domain index:
```typescript
// index.ts
export * from './product.schema.js';
```

4. Add to schema index `libs/database/src/schema/index.ts`:
```typescript
export * from './product/index.js';
```

5. Generate migration:
```bash
pnpm --filter @act/database db:generate
```

**Schema-Type Relationship:**
- Types in `libs/types` define the domain model (what the application works with)
- Schemas in `libs/database` define the database structure (how data is stored)
- Repositories map between database rows and domain types
- Each domain gets its own PostgreSQL schema for isolation

---

## How to Add a New Repository

Location: `modules/<module>/repository/<name>.repository.ts`

Repositories use Drizzle ORM with the `DRIZZLE` injection token from `@act/database`.

```typescript
import { Injectable, Inject } from '@nestjs/common';
import { DRIZZLE, DrizzleDB, products, eq } from '@act/database';
import { Product } from '@act/types';

@Injectable()
export class ProductRepository {
  constructor(@Inject(DRIZZLE) private readonly db: DrizzleDB) {}

  async findAll(): Promise<Product[]> {
    const result = await this.db.select().from(products);
    return result.map(this.mapToProduct);
  }

  async findById(id: string): Promise<Product | null> {
    const result = await this.db.select().from(products).where(eq(products.id, id));
    return result[0] ? this.mapToProduct(result[0]) : null;
  }

  async create(data: Omit<Product, 'id'>): Promise<Product> {
    const result = await this.db.insert(products).values(data).returning();
    return this.mapToProduct(result[0]);
  }

  async update(id: string, data: Partial<Product>): Promise<Product | null> {
    const result = await this.db
      .update(products)
      .set({ ...data, updatedAt: new Date() })
      .where(eq(products.id, id))
      .returning();
    return result[0] ? this.mapToProduct(result[0]) : null;
  }

  async delete(id: string): Promise<boolean> {
    const result = await this.db.delete(products).where(eq(products.id, id)).returning();
    return result.length > 0;
  }

  private mapToProduct(row: typeof products.$inferSelect): Product {
    return {
      id: row.id,
      name: row.name,
      price: Number(row.price),
      description: row.description ?? '',
    };
  }
}
```

Register in module:
```typescript
import { Module } from '@nestjs/common';
import { ProductRepository } from '../repository';

@Module({
  providers: [ProductRepository],
  exports: [ProductRepository],
})
export class ProductModule {}

---

## How to Add a New Type/Schema

Location: `libs/types/<domain>/<name>.type.ts`

```typescript
import { z } from 'zod';

export const productSchema = z.object({
  id: z.string(),
  name: z.string(),
  price: z.number().positive(),
  description: z.string().optional(),
});

export type Product = z.infer<typeof productSchema>;
```

Export from `libs/types/<domain>/index.ts` and `libs/types/index.ts`.

---

## How to Add Unit Tests

Location: Same folder as source, with `.spec.ts` suffix

```typescript
// customer.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { CustomerService } from './customer.service';

describe('CustomerService', () => {
  let service: CustomerService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [CustomerService],
    }).compile();

    service = module.get<CustomerService>(CustomerService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('findAll', () => {
    it('should return array', async () => {
      const result = await service.findAll();
      expect(Array.isArray(result)).toBe(true);
    });
  });
});
```

---

## Dependency Rules

- Do NOT add packages already in root `package.json`
- Use `@act/*` for internal packages (e.g., `@act/types`, `@act/customer`)
- Use peer dependencies for NestJS core packages in modules

